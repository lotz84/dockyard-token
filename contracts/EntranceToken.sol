pragma solidity ^0.4.24;

import "zeppelin-solidity/contracts/math/SafeMath.sol";
import "zeppelin-solidity/contracts/ownership/Ownable.sol";

import "./DrinkToken.sol";

contract EntranceToken is Ownable {
  using SafeMath for uint256;

  struct Token {
    string entranceAt;
    uint256 amountOfDrinkToken;
    uint256 price;
  }

  // Stock is template for each token.
  Token[] public stocks;
  uint256[] public stockRemainings;

  Token[] public tokens;

  mapping(address => uint256[]) public userTokens;
  mapping(uint256 => uint256) tokenIndex;

  DrinkToken drinkToken;

  constructor(address drinkTokenAddress) public {
    drinkToken = DrinkToken(drinkTokenAddress);
  }

  function stockCount() public view returns (uint256) {
    return stocks.length;
  }

  function userTokenCount() public view returns (uint256) {
    return userTokens[msg.sender].length;
  }

  // Only owner can register stock for new entrance token.
  function createStock(
    string entranceAt,
    uint256 amountOfDrinkToken,
    uint256 price,
    uint256 amount) public onlyOwner returns (uint256 stockId){

    require(amountOfDrinkToken >= 0);
    require(price >= 0);
    require(amount > 0);

    Token memory stock = Token(entranceAt, amountOfDrinkToken, price);
    stockId = stocks.push(stock) - 1;
    stockRemainings.push(amount);
  }

  function _mint(address user, uint256 tokenId) private {
    uint256 index = userTokens[user].push(tokenId) - 1;
    tokenIndex[tokenId] = index;
  }

  // When user buy a token, token will generated by copying stock.
  function buyToken(uint256 stockId) public payable returns (uint256 tokenId) {
    uint256 remainings = stockRemainings[stockId];
    require(remainings > 0);

    Token storage token = stocks[stockId];
    require(msg.value >= token.price);

    // minting new token
    // tokenId starts from 1
    tokenId = tokens.push(token);
    _mint(msg.sender, tokenId);

    stockRemainings[stockId]--;
  }

  function _burn(address user, uint256 tokenId) private {
    uint256 index = tokenIndex[tokenId];
    require(userTokens[user][index] == tokenId);
    delete userTokens[user][index];
  }

  function transfer(address to, uint256 tokenId) public {
    Token memory token = tokens[tokenId - 1];
    _burn(msg.sender, tokenId);
    uint256 newTokenId = tokens.push(token);
    _mint(to, newTokenId);
  }

  // When user use a token, user will get some DrinkTokens and the token will burned.
  function useToken(uint256 tokenId) public {
    Token memory token = tokens[tokenId - 1];
    _burn(msg.sender, tokenId);

    // transfer DrinkToken
    drinkToken.transferFrom(owner, msg.sender, token.amountOfDrinkToken);
  }
}
